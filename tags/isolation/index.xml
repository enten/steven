<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Isolation on enten.fr</title>
    <link>http://enten.github.io/steven/tags/isolation/</link>
    <description>Recent content in Isolation on enten.fr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-FR</language>
    <copyright>(c) 2015 Steven Enten</copyright>
    <lastBuildDate>Tue, 30 Dec 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://enten.github.io/steven/tags/isolation/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LXC et Android 5 ARM64</title>
      <link>http://enten.github.io/steven/2014/12/30/lxc-et-android-5-arm64/</link>
      <pubDate>Tue, 30 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://enten.github.io/steven/2014/12/30/lxc-et-android-5-arm64/</guid>
      <description>

&lt;h2 id=&#34;introduction:73f568a5d974ee5ceff045d666741606&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://linuxcontainers.org/lxc/introduction/&#34;&gt;LXC&lt;/a&gt; (contraction de &lt;em&gt;Linux Containers&lt;/em&gt;) est un logiciel permettant de gérer des conteneurs logiciels. Conrètement, LXC peut isole l&amp;rsquo;exécution de plusieurs environnements Linux sur une même machine. L&amp;rsquo;isolation est réalisée grâce à l&amp;rsquo;exploitation des modules de gestion de namespaces du Kernel Linux.&lt;/p&gt;

&lt;p&gt;Depuis la publication d&amp;rsquo;un &lt;a href=&#34;https://www.stgraber.org/2013/12/23/lxc-1-0-some-more-advanced-container-usage/&#34;&gt;article en décembre 2013 sur le blog d&amp;rsquo;un des principaux développeurs de LXC (Stéphane Graber)&lt;/a&gt;, la communauté d&amp;rsquo;utilisateurs de conteneurs logiciels est consciente de la possibilité d&amp;rsquo;utiliser LXC sur un appareil Android. Stéphane Graber en a fait la &lt;a href=&#34;https://www.youtube.com/watch?v=XZWy2g9YY30&#34;&gt;démonstration à l&amp;rsquo;occasion de l&amp;rsquo;évènement Linux Plumbers Conference de septembre 2013&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Les gestionnaires de conteneurs boulversent progressivement les domaines de l&amp;rsquo;informatique liés à la virtualisation. Le possible usage de LXC sur Android offre des perspectives nouvelles pour l&amp;rsquo;industrie et la recherche. Un développeur a d&amp;rsquo;ailleurs démontré (durant l&amp;rsquo;évènement Droidconf de décembre 2013) le potentiel de LXC en étant capable de &lt;a href=&#34;https://www.youtube.com/watch?v=UpIFByNLM5U&#34;&gt;changer à chaud la version d&amp;rsquo;Android avec une simple application&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;LXC n&amp;rsquo;étant pas une application du Google Play Store, son installation sur Android n&amp;rsquo;est pas évidente. L&amp;rsquo;utilisateur qui souhaite se lancer sur cette voie est rapidement confronté à des problèmes systèmes. &lt;strong&gt;Dans la sections suivantes, nous décrivons les principaux problèmes que nous avons rencontrés pour installer et utiliser LXC sur Android 5 Lollipop&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;contexte:73f568a5d974ee5ceff045d666741606&#34;&gt;Contexte&lt;/h2&gt;

&lt;p&gt;Avant d&amp;rsquo;aborder les problèmes d&amp;rsquo;installation de LXC sur Android que nous avons rencontrés, il est important que le lecteur ait connaissance de notre plateforme de test.&lt;/p&gt;

&lt;h3 id=&#34;matériel:73f568a5d974ee5ceff045d666741606&#34;&gt;Matériel&lt;/h3&gt;

&lt;p&gt;Nous avons souhaité réaliser ces tests sur un appareil disposant d&amp;rsquo;une architecture ARM 64-bits (ARMv8). Ce type d&amp;rsquo;appareil n&amp;rsquo;étant pas encore démocratisé, nous avons fait le choix d&amp;rsquo;utiliser une machine virtuelle Qemu.&lt;/p&gt;

&lt;p&gt;Pour lancer la machine virtuelle de notre appareil fictif, nous utilisons une version dérivée de Qemu. Cette version est issue de la compilation de la branche &lt;a href=&#34;https://qemu-android.googlesource.com/qemu-android/+/ranchu&#34;&gt;ranchu&lt;/a&gt; du projet &lt;a href=&#34;https://qemu-android.googlesource.com/qemu-android/&#34;&gt;qemu-android&lt;/a&gt; d&amp;rsquo;AOSP. L&amp;rsquo;avantage de cette version est son support de machines virtuelles à l&amp;rsquo;architecture ARM 64-bits.&lt;/p&gt;

&lt;p&gt;Une fois lancé, notre appareil virtuel dispose d&amp;rsquo;un CPU cortex-a57 et de 4Go de mémoire vive. Il dispose également de 16Go de mémoire disque (en modifiant la taille de l&amp;rsquo;image &lt;code&gt;data.img&lt;/code&gt;, voir section suivante).&lt;/p&gt;

&lt;h3 id=&#34;système-d-exploitation:73f568a5d974ee5ceff045d666741606&#34;&gt;Système d&amp;rsquo;exploitation&lt;/h3&gt;

&lt;p&gt;Notre choix d&amp;rsquo;architecture ARM 64-bits nous impose l&amp;rsquo;utilisation de la version 5 (Lollipop) d&amp;rsquo;Android car c&amp;rsquo;est la seule version supportant ce type d&amp;rsquo;architecture.&lt;/p&gt;

&lt;p&gt;Pour obtenir les images des systèmes de fichiers d&amp;rsquo;Android 5 utilisées pour lancer notre appareil virtuel (&lt;code&gt;ramdisk.img&lt;/code&gt;, &lt;code&gt;system.img&lt;/code&gt;, &lt;code&gt;userdata.img&lt;/code&gt; et &lt;code&gt;cache.img&lt;/code&gt;), nous avons utilisé la configuration de compilation &lt;code&gt;ranchu&lt;/code&gt; de la branche &lt;a href=&#34;https://android.googlesource.com/platform/manifest/+/refs/heads/android-5.0.0_r7&#34;&gt;android-5.0.0_r7&lt;/a&gt; des sources du projet &lt;a href=&#34;https://source.android.com/&#34;&gt;Android Open Source Project&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Pour obtenir un espace disque important dans notre appareil virtuel, nous avons redimensionné l&amp;rsquo;image du système de fichiers utilisateur (&lt;code&gt;userdata.img&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Augmenter la taille de l&#39;image userdata.img d&#39;environs 16Go
dd if=/dev/zero bs=1M count=16000 &amp;gt;&amp;gt; userdata.img
e2fsck -f userdata.img
resize2fs userdata.img
e2fsck -f userdata.img
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kernel-linux:73f568a5d974ee5ceff045d666741606&#34;&gt;Kernel Linux&lt;/h3&gt;

&lt;p&gt;Nous utilisons une version dérivée du noyau Linux. Cette version correspond à la version 3.10 du noyau officiel. Ce noyau est précompilé dans les sources d&amp;rsquo;AOSP et est disponible dans le répertoire &lt;code&gt;prebuilts/qemu-kernel/arm64&lt;/code&gt; sous le fichier &lt;code&gt;kernel-qemu&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Un projet spécifique est consacré à ce noyau dans le dépôt des sources d&amp;rsquo;AOSP : &lt;a href=&#34;https://android.googlesource.com/kernel/goldfish/&#34;&gt;kernel/goldfish&lt;/a&gt;. Pour recompiler ce noyau adapté à Qemu, nous avons utilisé la branche &lt;a href=&#34;https://android.googlesource.com/kernel/goldfish/+/android-goldfish-3.10&#34;&gt;android-goldfish-3.10&lt;/a&gt; du projet.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note : &lt;code&gt;goldfish&lt;/code&gt; désigne les modules des périphériques virtuels nécessaires pour virtualiser Android avec Qemu. Nous vous recommandons la lecture de &lt;a href=&#34;https://android.googlesource.com/platform/external/qemu.git/+/master/docs/GOLDFISH-VIRTUAL-HARDWARE.TXT&#34;&gt;GOLDFISH-VIRTUAL-HARDWARE.TXT&lt;/a&gt; pour en savoir plus.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;configuration-réseau:73f568a5d974ee5ceff045d666741606&#34;&gt;Configuration réseau&lt;/h3&gt;

&lt;p&gt;Pour que notre appareil fictif ait sa propre adresse IP, nous avons configuré une interface réseau virtuelle connectée à la machine host (utilisée pour les tests) via une interface bridge.&lt;/p&gt;

&lt;p&gt;Ainsi, lorsque l&amp;rsquo;appareil virtuel Android est démarré, il suffit de lancer la directive &lt;code&gt;dhcpcd eth0&lt;/code&gt; pour demander au DHCP du réseau l&amp;rsquo;attribution d&amp;rsquo;une adresse IP (grâce à l&amp;rsquo;interface bridge, le DHCP traite la requête de notre périphérique virtuel comme celle de n&amp;rsquo;importe quelle machine physique du réseau).&lt;/p&gt;

&lt;h2 id=&#34;problèmes-fondamentaux:73f568a5d974ee5ceff045d666741606&#34;&gt;Problèmes fondamentaux&lt;/h2&gt;

&lt;h3 id=&#34;système-unix-restreint:73f568a5d974ee5ceff045d666741606&#34;&gt;Système Unix restreint&lt;/h3&gt;

&lt;h4 id=&#34;problème:73f568a5d974ee5ceff045d666741606&#34;&gt;Problème&lt;/h4&gt;

&lt;p&gt;Android est un système d&amp;rsquo;exploitation Linux destiné à piloter des systèmes embarqués. La philosophie d&amp;rsquo;Android a conduit ses développeurs à intégrer les outils systèmes uniquement nécessaire à son fonctionnement.&lt;/p&gt;

&lt;p&gt;Cette optimisation du système fait d&amp;rsquo;Android une &lt;strong&gt;distribution Linux &amp;laquo;restrictive&amp;raquo; dans le sens où les utilisateurs&lt;/strong&gt;, familiarisés à l&amp;rsquo;utilisation d&amp;rsquo;une des distribution Linux majeures (Debian par exemple), &lt;strong&gt;ne retrouvent pas les outils nécessaires à leurs usages habituels&lt;/strong&gt; (comme un gestionnaire de paquets).&lt;/p&gt;

&lt;h4 id=&#34;solution:73f568a5d974ee5ceff045d666741606&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Pour pouvoir utiliser certains utilitaires UNIX absents d&amp;rsquo;Android, il est d&amp;rsquo;usage d&amp;rsquo;&lt;strong&gt;installer une version ARM de &lt;a href=&#34;http://busybox.net/about.html&#34;&gt;busybox&lt;/a&gt;&lt;/strong&gt; (en copiant son binaire dans le répertoire &lt;code&gt;/system/bin&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Les utilitaires fournis par &lt;code&gt;busybox&lt;/code&gt; ne suffisent pas à combler les lacunes d&amp;rsquo;Android. Néanmoins ils nous ont permis d&amp;rsquo;&lt;strong&gt;installer et de configurer un rootfs Archlinux&lt;/strong&gt;. Ainsi, nous disposons maintenant d&amp;rsquo;une distribution Archlinux embarquée dans notre appareil Android afin d&amp;rsquo;étendre son fonctionnement.&lt;/p&gt;

&lt;p&gt;On peut alors installer facilement LXC grâce à &lt;code&gt;pacman&lt;/code&gt;, le gestionnaire de paquets d&amp;rsquo;Archlinux.&lt;/p&gt;

&lt;h3 id=&#34;echec-des-connexions-https:73f568a5d974ee5ceff045d666741606&#34;&gt;Echec des connexions HTTPS&lt;/h3&gt;

&lt;h4 id=&#34;problème-1:73f568a5d974ee5ceff045d666741606&#34;&gt;Problème&lt;/h4&gt;

&lt;p&gt;Une fois le rootfs Archlinux installé et configuré, nous avons souhaité mettre à jour les paquets et installer le paquet LXC. Au cours de cette manipulation, nous avons constaté l&amp;rsquo;&lt;strong&gt;impossibilité d&amp;rsquo;établir une connexion via le protocole &lt;code&gt;https&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;solution-1:73f568a5d974ee5ceff045d666741606&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Ce problème est lié à la date du système. En effet, la date de notre appareil virtuel une fois lancé est assignée au 1/1/1970. Pour corriger ce problème, &lt;strong&gt;il suffit de mettre à jour la date du système&lt;/strong&gt; (avec l&amp;rsquo;utilitaire &lt;code&gt;rdate&lt;/code&gt; de &lt;code&gt;busybox&lt;/code&gt; par exemple).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;busybox rdate -s ntp.unice.fr
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;modules-du-kernel-manquants:73f568a5d974ee5ceff045d666741606&#34;&gt;Modules du Kernel manquants&lt;/h3&gt;

&lt;h4 id=&#34;problème-2:73f568a5d974ee5ceff045d666741606&#34;&gt;Problème&lt;/h4&gt;

&lt;p&gt;Après avoir installé LXC avec &lt;code&gt;pacman&lt;/code&gt;, et avant de lancer notre premier test de conteneur, nous avons utilisé le script &lt;a href=&#34;https://github.com/lxc/lxc/blob/master/src/lxc/lxc-checkconfig.in&#34;&gt;lxc-checkconfig&lt;/a&gt;. Ce script lit la configuration du kernel utilisée pour sa compilation. Il vérifit la présence de certaines constantes nécessaires à la compilation des modules requis par LXC. Avec ce script, nous avons pu constater l&amp;rsquo;&lt;strong&gt;absence de modules (du kernel précompilé) nécessaires au bon fonctionnement de LXC&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;solution-2:73f568a5d974ee5ceff045d666741606&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Nous avons &lt;strong&gt;recompilé le kernel&lt;/strong&gt; à partir des sources du projet &lt;code&gt;kernel/goldfish&lt;/code&gt;. Avant de recompiler le kernel, nous avons &lt;strong&gt;modifié la configuration de compilation &lt;code&gt;ranchu_defconfig&lt;/code&gt;&lt;/strong&gt; (fichier uniquement présent dans le répertoire &lt;code&gt;arch/arm64/configs/&lt;/code&gt; de la branche &lt;code&gt;android-goldfish-3.10&lt;/code&gt;) pour y ajouter les constantes suivantes :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;CONFIG_IPC_NS=y
CONFIG_PID_NS=y
CONFIG_PID_IN_CONTEXTIDR=y
CONFIG_NET_NS=y
CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
CONFIG_CGROUP_DEVICE=y
CONFIG_CGROUP_CPUACCT=y
CONFIG_CPUSETS=y
CONFIG_VETH=y
CONFIG_UTS_NS=y
CONFIG_CGROUP_FREEZER=y
CONFIG_CGROUP_PERF=y
CONFIG_RESOURCE_COUNTERS=y
CONFIG_MEMCG=y
CONFIG_MEMCG_SWAP=y
#CONFIG_USER_NS=y
CONFIG_BTRFS_FS=y
CONFIG_EXT4_FS_POSIX_ACL=y
CONFIG_EXT4_FS_SECURITY=y
CONFIG_MACVLAN=y
CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
CONFIG_VLAN_8021Q=y
CONFIG_BLK_CGROUP=y
CONFIG_CFQ_GROUP_IOSCHED=y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt; : La constante &lt;code&gt;CONFIG_USER_NS&lt;/code&gt; est volontairement désactivée à cause d&amp;rsquo;un problème de compilation (lié à la version des sources de ce module).&lt;/p&gt;

&lt;h3 id=&#34;impossibilité-de-lancer-des-binaires-non-pie:73f568a5d974ee5ceff045d666741606&#34;&gt;Impossibilité de lancer des binaires non-PIE&lt;/h3&gt;

&lt;h4 id=&#34;problème-3:73f568a5d974ee5ceff045d666741606&#34;&gt;Problème&lt;/h4&gt;

&lt;p&gt;Au cours de nos tests, nous avons rencontré une sécurité système propre à Android 5 (branche &lt;code&gt;android-5.0.0_r7&lt;/code&gt;). Ce test de sécurité &lt;strong&gt;bloque l&amp;rsquo;exécution de fichiers binaires non-&lt;a href=&#34;http://en.wikipedia.org/wiki/Position-independent_code&#34;&gt;PIE&lt;/a&gt;&lt;/strong&gt;. Pour qu&amp;rsquo;un exécutable soit PIE, il faut le spécifier à sa compilation.&lt;/p&gt;

&lt;h4 id=&#34;solution-3:73f568a5d974ee5ceff045d666741606&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Pour outre passer cette sécurité, un &lt;a href=&#34;http://forum.xda-developers.com/google-nexus-5/development/fix-bypassing-pie-security-check-t2797731&#34;&gt;patch a été développé par un membre du forum XDA-Developers&lt;/a&gt;. Cette solution semble fonctionner selon certains utilisateurs. Nous avons préférés &lt;strong&gt;recompiler le code source en désactivant cette sécurité&lt;/strong&gt;. Pour cela nous avons commenter le bloc de code ci-dessous dans le fichier &lt;code&gt;bionic/linker/linker.cpp&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;2181    //if (elf_hdr-&amp;gt;e_type != ET_DYN) {
2182    //    __libc_format_fd(2, &amp;quot;error: only position independent executables (PIE) are supported.\n&amp;quot;);
2183    //    exit(EXIT_FAILURE);
2184    //}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cgroups-non-montés:73f568a5d974ee5ceff045d666741606&#34;&gt;Cgroups non-montés&lt;/h3&gt;

&lt;h4 id=&#34;problème-4:73f568a5d974ee5ceff045d666741606&#34;&gt;Problème&lt;/h4&gt;

&lt;p&gt;Lorsque non consultons le fichier &lt;code&gt;/proc/cgroups&lt;/code&gt;, nous constatons la présence plusieurs cgroups. Or lorsque nous consultons les périphériques montés (avec la commande &lt;code&gt;mount&lt;/code&gt;), nous avons constaté que seul le cgroup &lt;code&gt;memory&lt;/code&gt; était monté. &lt;strong&gt;La majorité des cgroups ne sont donc pas montés&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;solution-4:73f568a5d974ee5ceff045d666741606&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Il faut &lt;strong&gt;monter les cgroups manquants&lt;/strong&gt;. Pour cela nous nous sommes basés sur les &lt;a href=&#34;https://github.com/tianon/cgroupfs-mount/&#34;&gt;scripts de tianon&lt;/a&gt; à la différence que nous montons les cgroups dans la racine de notre rootfs Archlinux (étant donné que nous utilisons LXC à travers ce rootfs).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;for i in $(busybox awk &#39;!/^#/ { if ($4 == 1) print $1 }&#39; /proc/cgroups); do
    if ! grep -q &amp;quot; $ROOTFS/$i &amp;quot; /proc/mounts; then
        mkdir -p $ROOTFS/$i
        /system/bin/busybox mount -n -t cgroup -o $i cgroup $ROOTFS/$i
    fi
done 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt; : si l&amp;rsquo;arborescence des cgroups n&amp;rsquo;est pas montée dans le rootfs, il ne sera pas possible de lancer plus d&amp;rsquo;un conteneur à la fois.&lt;/p&gt;

&lt;h3 id=&#34;echec-d-utilisation-des-cgroups-dans-un-rootfs:73f568a5d974ee5ceff045d666741606&#34;&gt;Echec d&amp;rsquo;utilisation des cgroups dans un rootfs&lt;/h3&gt;

&lt;h4 id=&#34;problème-5:73f568a5d974ee5ceff045d666741606&#34;&gt;Problème&lt;/h4&gt;

&lt;p&gt;Bien que les cgroups soient montés, ceux-ci sont &lt;strong&gt;inutilisables à cause d&amp;rsquo;un problème d&amp;rsquo;autorisation d&amp;rsquo;écriture&lt;/strong&gt; semble-t-il. N&amp;rsquo;ayant aucune expérience en matière d&amp;rsquo;utilisation des modules de gestion des namespaces, nous ne savions pas comment corriger ce problème. Néanmoins, nous étions persuadés que le problème était propre à Android (et probablement au fait qu&amp;rsquo;on utilise LXC à travers un rootfs).&lt;/p&gt;

&lt;h4 id=&#34;solution-5:73f568a5d974ee5ceff045d666741606&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Pour tenter de résoudre ce problème, nous avons analysés les &lt;a href=&#34;https://web.archive.org/web/20140723085319/https://qa.linuxcontainers.org/master/current/android-armel/lxc-android.tar.gz&#34;&gt;fichiers utilisés par S. Graber&lt;/a&gt; dans sa démonstration de décembre 2013. Nous avons constaté qu&amp;rsquo;il utilisait un programme appellé &lt;code&gt;sbin&lt;/code&gt; pour remonter recursivement la racine du téléphone &lt;code&gt;/&lt;/code&gt; en mode privé.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;En remontant la racine de notre appareil virtuel en mode privé (avec le programme &lt;code&gt;sbin&lt;/code&gt;) et en démarrant le programme &lt;a href=&#34;https://linuxcontainers.org/fr/cgmanager/introduction/&#34;&gt;cgmanager&lt;/a&gt; dans notre rootfs Archlinux, nous avons pu lancer notre premier conteneur LXC sur Android.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note : le programme &lt;code&gt;sbin&lt;/code&gt; récupérée dans l&amp;rsquo;archive de S. Graber est non-PIE. Il est inutilisable si le programme &lt;code&gt;linker&lt;/code&gt; d&amp;rsquo;Android 5 n&amp;rsquo;est pas patché (comme expliqué précédemment).&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;conteneur-sans-accès-réseau:73f568a5d974ee5ceff045d666741606&#34;&gt;Conteneur sans accès réseau&lt;/h3&gt;

&lt;h4 id=&#34;problème-6:73f568a5d974ee5ceff045d666741606&#34;&gt;Problème&lt;/h4&gt;

&lt;p&gt;Par défaut, la configuration réseau d&amp;rsquo;un conteneur est vide. Sans configuration réseau, &lt;strong&gt;le conteneur ne dispose pas d&amp;rsquo;interface pour être connecté en réseau (pas d&amp;rsquo;adresse IP)&lt;/strong&gt;. La configuration réseau &amp;laquo;vide&amp;raquo; est indiquée dans le fichier de configuration d&amp;rsquo;un conteneur par la ligne suivante :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Network configuration
lxc.network.type = empty
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;solution-6:73f568a5d974ee5ceff045d666741606&#34;&gt;Solution&lt;/h4&gt;

&lt;p&gt;Parmis les différents types de configuration réseau supportés par LXC, &lt;strong&gt;le type &lt;code&gt;macvlan&lt;/code&gt; et son mode &lt;code&gt;bridge&lt;/code&gt; nous ont permis d&amp;rsquo;obtenir une IP propre pour nos conteneurs&lt;/strong&gt;. Nous vous recommandons la lecture de cet &lt;a href=&#34;http://containerops.org/2013/11/19/lxc-networking/&#34;&gt;excellent article du blog containerops.org&lt;/a&gt; pour en savoir plus sur les différents types de configuration réseau de LXC.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Network configuration
lxc.network.type = macvlan
lxc.network.macvlan.mode = bridge
lxc.network.flags = up
lxc.network.link = eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Attention&lt;/strong&gt; ! Souvenez-vous que l&amp;rsquo;utilisation d&amp;rsquo;un type de configuration réseau dépend des modules du kernel et du matériel sur lequel il est installé (par exemple l&amp;rsquo;option &lt;code&gt;CONFIG_MACVLAN=y&lt;/code&gt; utilisée pour recompiler le kernel est nécessaire pour utiliser le type de configuration &lt;code&gt;macvlan&lt;/code&gt; de LXC).&lt;/p&gt;

&lt;h2 id=&#34;démonstration:73f568a5d974ee5ceff045d666741606&#34;&gt;Démonstration&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Cliquer sur l&amp;rsquo;image pour voir la vidéo.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.youtube.com/watch?v=1rW_lFyVY_w&#34;&gt;&lt;img src=&#34;http://img.youtube.com/vi/1rW_lFyVY_w/0.jpg&#34; alt=&#34;LXC on Android - Test 1&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:73f568a5d974ee5ceff045d666741606&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;L&amp;rsquo;installation de LXC sur Android requiert différentes maniputions du système. Afin de capitaliser les bonnes pratiques pour utiliser LXC sur Android, nous avons développé le script &lt;a href=&#34;https://gist.github.com/enten/63cedaca9bf019feb71a&#34;&gt;alfred&lt;/a&gt;. Cet outil est utilisé dans notre vidéo de démonstration.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>