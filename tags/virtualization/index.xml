<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Virtualization on enten.fr</title>
    <link>http://enten.github.io/steven/tags/virtualization/</link>
    <description>Recent content in Virtualization on enten.fr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-FR</language>
    <copyright>(c) 2015 Steven Enten</copyright>
    <lastBuildDate>Mon, 15 Jun 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://enten.github.io/steven/tags/virtualization/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Android 5.1.1 x86_64</title>
      <link>http://enten.github.io/steven/2015/06/15/android-5.1.1-x86_64/</link>
      <pubDate>Mon, 15 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://enten.github.io/steven/2015/06/15/android-5.1.1-x86_64/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Le projet &lt;a href=&#34;http://www.android-x86.org/&#34;&gt;android-x86&lt;/a&gt; est un fork d&amp;rsquo;Android Open Source Project (&lt;a href=&#34;http://source.android.com/&#34;&gt;AOSP&lt;/a&gt;) permettant d&amp;rsquo;installer Android sur PC (la compilation de ses sources produit une image CD bootable). Ce fork fût longtemps la seule solution pour compiler simplement Android pour plateforme x86.&lt;/p&gt;

&lt;p&gt;Avec &lt;a href=&#34;http://www.android.com/versions/lollipop-5-0/&#34;&gt;Android 5 Lollipop&lt;/a&gt;, Google a ouvert la voix à la compilation d&amp;rsquo;&lt;a href=&#34;http://source.android.com/&#34;&gt;AOSP&lt;/a&gt; pour architectures 64-bits (ARM et x86). Cette possibilité ne rend pas le fork &lt;a href=&#34;http://www.android-x86.org/&#34;&gt;android-x86&lt;/a&gt; obsolète pour autant.
En effet la compilation de ces 2 projets ne produit pas le même résultat (une unique image iso pour android-x86 contre plusieurs images de systèmes de fichiers pour AOSP).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Nous discuterons dans cette article uniquement d&amp;rsquo;AOSP et de la manière de compiler ses sources pour des architectures 64-bits.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;contexte&#34;&gt;Contexte&lt;/h2&gt;

&lt;p&gt;Peu de temps après notre expérience de &lt;a href=&#34;http://enten.github.io/steven/page/virtualiser-android-5-lollipop-avec-qemu/&#34;&gt;virtualisation d&amp;rsquo;Android 5 Lollipop avec Qemu&lt;/a&gt;, nous avons constaté que des images 64-bits précompilées d&amp;rsquo;Android étaient proposées en téléchargement par le &lt;a href=&#34;http://developer.android.com/tools/help/sdk-manager.html&#34;&gt;SDK Manager&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;!TODO Screen SDK images/fig/sdk-manager-images-64bits.png&lt;/p&gt;

&lt;p&gt;Le tableau ci-dessous montre les différentes images 64-bits (par version d&amp;rsquo;Android) actuellement disponibles en téléchargement via le &lt;a href=&#34;http://developer.android.com/tools/help/sdk-manager.html&#34;&gt;SDK Manager&lt;/a&gt;.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Codename&lt;/th&gt;
&lt;th&gt; Version&lt;/th&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;Images&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;5.1.1&lt;/td&gt;
&lt;td&gt;22 MNC Preview&lt;/td&gt;
&lt;td&gt;ARM 64 v8a System Image&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;5.1.1&lt;/td&gt;
&lt;td&gt;22 MNC Preview&lt;/td&gt;
&lt;td&gt;Intel x86 Atom_64 System Image&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Lollipop&lt;/td&gt;
&lt;td&gt;5.1.1&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;Intel x86 Atom_64 System Image&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Lollipop&lt;/td&gt;
&lt;td&gt;5.1.1&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;Goole APIs Intel x86 Atom-64 System Image&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Lollipop&lt;/td&gt;
&lt;td&gt;5.0.1&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;Intel x86 Atom_64 System Image&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Lollipop&lt;/td&gt;
&lt;td&gt;5.0.1&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;Goole APIs Intel x86 Atom-64 System Image&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Android M est semble-t-il la première version proposant une image ARM 64-bits précompilée (ce qui évite de prendre des heures à compiler soit-même AOSP pour ARM 64-bits).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Nous sommes maintenant certains qu&amp;rsquo;il est possible de compiler AOSP pour des architectures x86_64, et ce depuis la version 5.0.1 d&amp;rsquo;Android.&lt;/p&gt;

&lt;h2 id=&#34;expérience&#34;&gt;Expérience&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Dans cette section, nous allons compiler Android pour architecture x86_64 à partir des sources du projet officiel (AOSP).&lt;/strong&gt; Les images résultantes de la compilation pourront être utilisées directement avec Qemu ou l&amp;rsquo;outil &lt;a href=&#34;http://developer.android.com/tools/help/emulator.html&#34;&gt;emulator&lt;/a&gt; du SDK. &lt;strong&gt;Nous souhaitons également recompiler un kernel  Linux compatible&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;expérience semble simple. Toute fois, des problèmes de compatibilité de versions peuvent rendrent l&amp;rsquo;expérience moins évidente.&lt;/p&gt;

&lt;h3 id=&#34;prérequis-matériel&#34;&gt;Prérequis matériel&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Processeur amd64&lt;/li&gt;
&lt;li&gt;RAM &amp;ge; 4 Go&lt;/li&gt;
&lt;li&gt;Espace disque &amp;ge; 50 Go&lt;/li&gt;
&lt;li&gt;Système d&amp;rsquo;exploitation GNU/Linux récent&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;versions&#34;&gt;Versions&lt;/h3&gt;

&lt;p&gt;Voici les différentes versions des composants utilisés pour compiler AOSP x86_64.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Système d&amp;rsquo;exploitation : &lt;a href=&#34;https://www.debian.org/releases/jessie/&#34;&gt;Debian GNU/Linux 8 (jessie)&lt;/a&gt; 64-bits&lt;/li&gt;
&lt;li&gt;Java Development Kit : &lt;a href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html&#34;&gt;Oracle JDK 7 (1.7.0_79-b15)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Android Open Source Project : &lt;a href=&#34;https://android.googlesource.com/platform/manifest/+/android-5.1.1_r4&#34;&gt;android-5.1.1_r4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Toolchain : &lt;a href=&#34;https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.8/+/android-5.1.1_r4&#34;&gt;x86_64-linux-android-4.8&lt;/a&gt; (branche android-5.1.1_r4)&lt;/li&gt;
&lt;li&gt;Kernel : &lt;a href=&#34;https://android.googlesource.com/kernel/goldfish/+/43dbfdb838603e823d75cec871f0c317e8c20fc9&#34;&gt;android-goldfish-3.10 commit 43dbfdb838&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;
Pour pouvoir compiler un kernel Linux compatible avec les images résultantes de la compilation d&amp;rsquo;AOSP branche &lt;code&gt;android-5.1.1_r4&lt;/code&gt;, il est important d&amp;rsquo;utiliser la branche &lt;code&gt;android-goldfish-3.10&lt;/code&gt; du projet &lt;code&gt;kernel/goldfish&lt;/code&gt; à son état du 16 sept. 2014 (commit 43dbfdb838).&lt;/p&gt;

&lt;h3 id=&#34;préparer-l-environnement-d-assemblage&#34;&gt;Préparer l&amp;rsquo;environnement d&amp;rsquo;assemblage&lt;/h3&gt;

&lt;h4 id=&#34;jdk-7&#34;&gt;JDK 7&lt;/h4&gt;

&lt;p&gt;Installer un JDK 7 (Java Open JDK 7 par exemple).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-get install openjdk-7-jdk –y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vérifier qu&amp;rsquo;il est bien utilisé par défaut.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo update-alternatives --config java
$ sudo update-alternatives --config javac
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;packages-requis&#34;&gt;Packages requis&lt;/h4&gt;

&lt;p&gt;Installer les packages nécessaires pour compiler AOSP.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dpkg --add-architecture i386
$ sudo apt-get install bison g++-multilib git gperf libxml2-utils make zlib1g-dev:i386 zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configurer une identité utilisateur sous Git&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git config --global user.name &amp;quot;John Doe&amp;quot;
$ git config --global user.email &amp;quot;jd@android.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Récupérer l&amp;rsquo;utilitaire repo de Google et le charger dans le &lt;code&gt;PATH&lt;/code&gt; courrant.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir ~/bin
$ curl https://storage.googleapis.com/git-repo-downloads/repo &amp;gt; ~/bin/repo
$ chmod a+x ~/bin/repo
$ PATH=~/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;small&gt;Référence : &lt;a href=&#34;http://source.android.com/source/initializing.html#setting-up-a-linux-build-environment&#34;&gt;Setting up a Linux build environment&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;h3 id=&#34;sources-d-aosp&#34;&gt;Sources d&amp;rsquo;AOSP&lt;/h3&gt;

&lt;p&gt;Nous allons maintenant récupérer les sources officielles d&amp;rsquo;Android.&lt;/p&gt;

&lt;p&gt;Pour cela il suffit de créer un répertoire, de l&amp;rsquo;initialiser avec l&amp;rsquo;outil &lt;code&gt;repo&lt;/code&gt; et la branche souhaitée (&lt;code&gt;android-5.1.1_r4&lt;/code&gt;) puis de lancer le téchargement des sources.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir ~/aosp
$ cd ~/aosp
$ repo init -u https://android.googlesource.com/platform/manifest -b android-5.1.1_r4
$ repo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Attention&lt;/strong&gt; La synchronisation des sources d&amp;rsquo;AOSP dure plusieurs heures (à la faveur d&amp;rsquo;une connexion Internet grand public).&lt;/p&gt;

&lt;h3 id=&#34;compiler-aosp&#34;&gt;Compiler AOSP&lt;/h3&gt;

&lt;p&gt;Une fois les sources d&amp;rsquo;AOSP récupérées, quelques lignes de commandes suffisent à charger la configuration d&amp;rsquo;assemblage &lt;code&gt;aosp_x86_64-eng&lt;/code&gt; pour produire des images x86_64 d&amp;rsquo;Android.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd ~/aosp
$ source build/envsetup.sh
$ lunch aosp_x86_64-eng
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Avant de lancer la compilation, vérifions que le toolchain &lt;a href=&#34;https://android.googlesource.com/platform/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.8/+/android-5.1.1_r4&#34;&gt;x86_64-linux-android-4.8&lt;/a&gt; figure bien dans notre &lt;code&gt;PATH&lt;/code&gt; (il a automatiquement été chargé dedans via &lt;code&gt;lunch&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo $PATH | grep &#39;x86_64-linux-android-4.8&#39;

# Le contenu du PATH doit s&#39;afficher à l&#39;écran
# avec le tooclhain dans le répertoire :
# &amp;lt;aosp&amp;gt;/prebuilts/gcc/linux_x86/x86/x86_64-linuxandroid-4.8/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Maintenant que tout est prêt nous pouvons lancer la compilation via plusieurs threads en fonction des capacités de l&amp;rsquo;ordinateur.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make –j8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Attention&lt;/strong&gt; La compilation dure également plusieurs heures selon le nombre de threads utilisés pour compiler et les capacités de l&amp;rsquo;ordinateur :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;environs 3h30 pour un PC avec un processeur 4 coeurs, 8 Go  de RAM et 8 threads pour compiler ;&lt;/li&gt;
&lt;li&gt;environs 1h30 pour un PC avec un processeur 8 coeurs, 32 Go de RAM et 32 threads pour compiler.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;A la fin de la comilation, les images des systèmes de fichiers créées sont disponibles dans le répertoire &lt;code&gt;&amp;lt;aosp&amp;gt;/out/target/production/generic_x86_64&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;compiler-goldfish&#34;&gt;Compiler Goldfish&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://android.googlesource.com/kernel/goldfish&#34;&gt;Goldfish&lt;/a&gt; est une version du kernel Linux adaptée pour Android. Lorsque l&amp;rsquo;on utilise l&amp;rsquo;&lt;a href=&#34;http://developer.android.com/tools/help/avd-manager.html&#34;&gt;AVD Manager&lt;/a&gt; pour créer des émulateurs, des images pré-compilées du kernel Goldfish sont utilisées.&lt;/p&gt;

&lt;p&gt;Comme on aime les défis, nous allons le compiler nous-même. Les sources de Goldfish ne faisant pas parties d&amp;rsquo;AOSP (mais du projet Linux), elles sont stockées dans un dépôt à part entière.&lt;/p&gt;

&lt;p&gt;Récupérer le dépôt du kernel Linux Goldfish.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git clone https://android.googlesource.com/kernel/goldfish.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Une fois le dépôt récupéré, nous allons sélectionner la branche &lt;code&gt;android-goldfish-3.10&lt;/code&gt; et ramener les sources à leur état du 16/09/2014.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd goldfish
$ git checkout android-goldfish-3.10
$ git reset --hard 43dbfdb838603e823d75cec871f0c317e8c20fc9
# HEAD is now at 43dbfdb goldfish: Disable Seccomp for Intel builds.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Avant de compiler le kernel Goldfish, il faut vérifier que le toolchain 4.8 est toujours dans notre PATH. Si ce n&amp;rsquo;est pas le cas, rajoutez le.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;PATH=$PATH:~/aosp/prebuilts/gcc/linux_x86/x86/x86_64-linuxandroid-4.8/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il ne nous reste qu&amp;rsquo;à préparer la configuration d&amp;rsquo;assemblage et de lancer la compilation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make x86_64_emu_defconfig
make -j8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;A la fin de la comilation, le kernel compilé est disponible dans le répertoire &lt;code&gt;&amp;lt;goldfish&amp;gt;/arch/x86/boot&lt;/code&gt; sous le nom &lt;code&gt;bzImage&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;tester&#34;&gt;Tester&lt;/h3&gt;

&lt;p&gt;Nous disposons maintenant de tous les fichiers nécessaires pour lancer un émulateur Android x86_64 100% custom (recompilé par nos soins).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Images de systèmes de fichiers issues de la compilation d&amp;rsquo;AOSP dans le répertoire &lt;code&gt;&amp;lt;aosp&amp;gt;/out/target/product/generic_x86_64/&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cache.img&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;hardware-qemu.ini&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ramdisk.img&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;system.img&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;userdata-qemu.img&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Kernel Linux adapté à Android dans le répertoire : &lt;code&gt;&amp;lt;goldfish&amp;gt;/arch/x86/boot/&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bzImage&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Virtualiser Android 5 Lollipop avec Qemu</title>
      <link>http://enten.github.io/steven/2014/11/30/virtualiser-android-5-lollipop-avec-qemu/</link>
      <pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://enten.github.io/steven/2014/11/30/virtualiser-android-5-lollipop-avec-qemu/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Les dernières branches d&amp;rsquo;&lt;a href=&#34;https://source.android.com/&#34;&gt;Android Open Source Project&lt;/a&gt; (AOSP) – branches &lt;code&gt;android-5.x&lt;/code&gt; – proposent différentes configurations d&amp;rsquo;assemblages d&amp;rsquo;&lt;a href=&#34;https://www.android.com/versions/lollipop-5-0/&#34;&gt;Android 5 Lollipop&lt;/a&gt;.
Chaque configuration d&amp;rsquo;assemblage correspond à un produit adapté à un type de plateformes d&amp;rsquo;exécutions. Pour compiler une version complète d&amp;rsquo;Android 5 pour plateformes ARM, il faut utiliser la configuration d&amp;rsquo;assemblage &lt;code&gt;aosp_arm-eng&lt;/code&gt; (pour les plateformes ARM 32-bits) ou &lt;code&gt;aosp_arm64-eng&lt;/code&gt; (pour les plateformes ARM 64-bits).&lt;/p&gt;

&lt;p&gt;D&amp;rsquo;autres produits sont proposées à la compilation notamment les produits &lt;code&gt;ranchu_arm64-eng&lt;/code&gt; et &lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt; :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ranchu_arm64-eng&lt;/code&gt;&lt;/strong&gt; : la compilation de ce produit permet d&amp;rsquo;obtenir une version complète d&amp;rsquo;Android 5 ARM 64-bits destinée à être exécutée dans une machine virtuelle (VM) Qemu ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt;&lt;/strong&gt; : ce produit est similaire à &lt;code&gt;ranchu_arm64-eng&lt;/code&gt; à la différence que sa compilation permet d&amp;rsquo;obtenir une version simplifiée d&amp;rsquo;Android 5 embarquant le minimum de composants nécessaires à son fonctionnement.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La compilation d&amp;rsquo;un de ces produits créer des images de systèmes de fichiers (&lt;code&gt;ramdisk.img&lt;/code&gt;, &lt;code&gt;system.img&lt;/code&gt;, &lt;code&gt;cache.img&lt;/code&gt; et &lt;code&gt;userdata.img&lt;/code&gt;) devant être utilisées avec le &lt;a href=&#34;http://qemu.org/&#34;&gt;logiciel de virtualisation Qemu&lt;/a&gt;.
L&amp;rsquo;initialisation d&amp;rsquo;une VM Qemu avec le produit &lt;code&gt;ranchu_arm64-eng&lt;/code&gt; permet de virtualiser Android 5 et de le contrôler via son terminal ou son interface graphique. L&amp;rsquo;initialisation d&amp;rsquo;une VM Qemu avec le produit &lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt; est beaucoup plus rapide car les composants de l&amp;rsquo;environnement graphique ne sont pas chargés : seul le terminal permet de contrôler cette version allégée d&amp;rsquo;Android 5.&lt;/p&gt;

&lt;p&gt;Les dernières versions de Qemu (&lt;code&gt;2.x&lt;/code&gt;) permettent de virtualiser des machines ARM 64-bits. Cependant, aucun programme du projet officiel Qemu ne supporte la virtualisation de machines virtuelles pouvant exécuter le système d&amp;rsquo;exploitation (OS) Android. Google s&amp;rsquo;est chargé d&amp;rsquo;enrichir le projet Qemu pour proposer des programmes capables de virtualiser l&amp;rsquo;OS Android : c&amp;rsquo;est le projet &lt;a href=&#34;https://qemu-android.googlesource.com/&#34;&gt;qemu-android&lt;/a&gt;.
La compilation des sources du projet &lt;code&gt;qemu-android&lt;/code&gt; permet d&amp;rsquo;obtenir l&amp;rsquo;exécutable &lt;code&gt;qemu-system-aarch64&lt;/code&gt; nécessaire à la virtualisation de versions d&amp;rsquo;Android ARM 64-bits.&lt;/p&gt;

&lt;p&gt;Dans les sections suivantes, nous allons voir comment compiler Android 5 (produit &lt;code&gt;ranchu_arm64-eng&lt;/code&gt; ou &lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt;) et le virtualiser dans une VM Qemu.&lt;/p&gt;

&lt;h2 id=&#34;prérequis&#34;&gt;Prérequis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Capacités processeur et mémoire importantes (la compilation nécessite parfois jusqu’à 4 Go de RAM) ;&lt;/li&gt;
&lt;li&gt;Une configuration du bios autorisant la virtualisation ;&lt;/li&gt;
&lt;li&gt;Environ 100 Go d’espace disque libre (pour pouvoir compiler les deux produits) ;&lt;/li&gt;
&lt;li&gt;Une distribution d’un système d’exploitation Linux récente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Note : les manipulations décritent ci-dessous ont été réalisées sur un ordinateur disposant d’un processeur Intel Core i5 (2 cœurs cadencés à 1.8 Ghz supportant jusqu’à 4 threads par coeur), de 8 Go de mémoire RAM et de la distribution &lt;a href=&#34;http://releases.ubuntu.com/14.04.1&#34;&gt;Ubuntu 14.04.1 LTS&lt;/a&gt; 64-bits.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;préparer-l-environnement-d-assemblage&#34;&gt;Préparer l&amp;rsquo;environnement d&amp;rsquo;assemblage&lt;/h2&gt;

&lt;p&gt;Installer la machine virtuelle Java (JVM) Open JDK 7 (nécessaire pour compiler les dernières branches d&amp;rsquo;Android)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-get install openjdk-7-jdk –y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vérifier que Open JDK 7 est la JVM utilisée par défaut&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo update-alternatives --config java
$ sudo update-alternatives --config javac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Installer des packages nécessaires pour la compilation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-get install bison build-essential curl flex g++-multilib git gperf lib32z1 lib32z1-dev libglib2.0-dev libpixman-1-dev libswitch-perl libxml2-utils yasm zlib1g zlib1g-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configurer une identité utilisateur sous Git&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git config --global user.name &amp;quot;John Doe&amp;quot;
$ git config --global user.email &amp;quot;jd@android.com&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Récupérer l&amp;rsquo;utilitaire repo de Google et le charger dans le PATH courrant&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir ~/bin &amp;amp;&amp;amp; PATH=~/bin:$PATH
$ curl https://storage.googleapis.com/git-repo-downloads/repo &amp;gt; ~/bin/repo
$ chmod a+x ~/bin/repo
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;récupérer-les-sources-d-aosp&#34;&gt;Récupérer les sources d&amp;rsquo;AOSP&lt;/h2&gt;

&lt;p&gt;Créer un répertoire pour le dépôt des sources d&amp;rsquo;AOSP&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir –p ~/dev/aosp &amp;amp;&amp;amp; cd ~/dev/aosp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initialiser le dépôt avec la branche &lt;code&gt;android-5.0.0_r7&lt;/code&gt; d&amp;rsquo;Android&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ repo init -u https://android.googlesource.com/platform/manifest -b android-5.0.0_r7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Synchroniser le dépôt pour récupérer les sources (l&amp;rsquo;opération dure plusieurs heures à cause du volume important de données à télécharger)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ repo sync
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;corriger-les-configurations-d-assemblage&#34;&gt;Corriger les configurations d&amp;rsquo;assemblage&lt;/h2&gt;

&lt;p&gt;Les premières branches d&amp;rsquo;Android 5 souffrent de petits bugs nécessitant une modification manuelle des sources pour pouvoir compiler les produits &lt;code&gt;ranchu_arm64-eng&lt;/code&gt; et &lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt; :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ranchu_arm64-eng&lt;/code&gt;&lt;/strong&gt; : le script permettant de proposer ce produit à la compilation n&amp;rsquo;existe pas, il faut le rajouter ;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt;&lt;/strong&gt; : le choix de la configuration d&amp;rsquo;assemblage de ce produit indique que les fichiers compilés sont destinés à des plateformes ARM 32-bits (armv7), il faut modifier cela pour que les fichiers soit compilés pour plateformes ARM 64-bits (armv8).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Merci à &lt;a href=&#34;https://www.linkedin.com/in/vitorallo&#34;&gt;Vito Rallo&lt;/a&gt; qui a identifié ces bugs et qui propose une archive à décompresser dans le répertoire &lt;code&gt;device/generic&lt;/code&gt; pour les corriger.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd ~/dev
$ wget https://dl.dropboxusercontent.com/u/2930979/fixit.tar.gz
$ tar -xvf fixit.tar.gz -C aosp/device/generic
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;compiler-les-sources-d-aosp&#34;&gt;Compiler les sources d&amp;rsquo;AOSP&lt;/h2&gt;

&lt;p&gt;Se placer dans le dossier principal des sources d&amp;rsquo;AOSP&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd ~/dev/aosp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Initialiser l&amp;rsquo;environnement de compilation dans le terminal&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ source build/envsetup.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Charger la configuration d&amp;rsquo;assemblage du produit &lt;code&gt;ranchu_arm64-eng&lt;/code&gt; ou&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lunch ranchu_arm64-eng
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lancer la compilation en fonction des capacités de l&amp;rsquo;ordinateur (pour un processeur dual core supportant 4 threads par cœur, 8 threads peuvent être utilisés pour la compilation)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ make –j8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A la fin de la comilation, les images des systèmes de fichiers créées sont disponibles dans un sous répertoire du dossier &amp;laquo;out&amp;raquo;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pour &lt;code&gt;ranchu_arm64-eng&lt;/code&gt; : out/target/product/generic_arm64/&lt;/li&gt;
&lt;li&gt;Pour &lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt; : out/target/product/mini-emulator-arm64/&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;virtualiser-la-version-compilée-d-android-avec-qemu&#34;&gt;Virtualiser la version compilée d&amp;rsquo;Android avec Qemu&lt;/h2&gt;

&lt;p&gt;Pour virtualiser une version d&amp;rsquo;Android 5 ARM 64-bits, nous avons besoin du programme &lt;code&gt;qemu-system-aarch64&lt;/code&gt; modifié par Google pour supporter l&amp;rsquo;exécution de la machine virtuelle &amp;laquo;ranchu&amp;raquo; (et du type de processeur &amp;laquo;cortex-v57&amp;raquo;).&lt;/p&gt;

&lt;p&gt;Initialiser le dépôt du projet &lt;code&gt;qemu-android&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd ~/dev
$ git clone https://qemu-android.googlesource.com/qemu-android
$ cd qemu-android
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compiler l&amp;rsquo;exécutable &lt;code&gt;qemu-system-aarch64&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ git submodule update --init dtc
$ git checkout origin/ranchu
$ ./configure --target-list=aarch64-softmmu
$ make -j8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Charger le programme compilée dans le PATH courrant (par lien symbolique)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ln -s ~/dev/qemu-android/aarch64-softmmu/qemu-system-aarch64 ~/bin/qemu-system-aarch64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nous sommes maintenant prêt à virtualiser Android 5 pour plateformes ARM 64-bits dans une VM Qemu grâce à l&amp;rsquo;exécutable &lt;code&gt;qemu-system-aarch64&lt;/code&gt;, nos images compilées de systèmes de fichiers et un kernel Qemu précompilé par Google.&lt;/p&gt;

&lt;p&gt;Se positionner dans le répertoire d&amp;rsquo;un des produits compilés&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd ~/dev/aosp/out/product/generic_arm64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Démarrer une VM Qemu avec Android 5 Lollipop&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;qemu-system-aarch64 -machine type=ranchu -cpu cortex-a57 -m 2048 -serial mon:stdio -show-cursor -kernel ~/dev/aosp/prebuilts/qemu-kernel/arm64/kernel-qemu -initrd ramdisk.img -drive index=2,id=userdata,file=userdata.img -device virtio-blk-device,drive=userdata -device virtio-blk-device,drive=cache -drive index=1,id=cache,file=cache.img -device virtio-blk-device,drive=system -drive index=0,id=system,file=system.img -netdev user,id=mynet -device virtio-net-device,netdev=mynet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Explication de la commande&lt;/strong&gt; :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-machine type=ranchu&lt;/code&gt; : on sélectionne le type de machine virtuelle &amp;laquo;ranchu&amp;raquo; adaptée à la virtualisation d&amp;rsquo;Android&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-cpu cortex-a57&lt;/code&gt; : on sélectionne le processeur virtuel pour plateformes ARM 64-bits&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m 2048&lt;/code&gt; : on alloue 2048 Mo de mémoire à la VM&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-serial mon:stdio&lt;/code&gt; : pour pouvoir contrôler le terminal de la VM&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-show-cursor&lt;/code&gt; : pour afficher le pointeur de la souris dans la VM&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-kernel&lt;/code&gt; : on utilise le kernel Qemu pour plateformes ARM 64-bits précompilé par Google&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-initrd&lt;/code&gt; : on utilise le fichier compilé &amp;laquo;ramdisk.img&amp;raquo; comme disque RAM initial&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-drive et -device&lt;/code&gt; : on monte les images de systèmes de fichiers compilés&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-netdev&lt;/code&gt; : pour profiter de la connexion réseau&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Aperçu de &lt;code&gt;ranchu_arm64-eng&lt;/code&gt;&lt;/strong&gt; :&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://enten.github.io/steven/assets/images/fig/ranchu_arm64-eng.png&#34;&gt;&lt;img src=&#34;http://enten.github.io/steven/assets/images/fig/ranchu_arm64-eng-tiny.png&#34; alt=&#34;ranchu_arm64-eng preview&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aperçu de &lt;code&gt;mini_emulator_arm64-userdebug&lt;/code&gt;&lt;/strong&gt; :&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://enten.github.io/steven/assets/images/fig/mini_emulator_arm64-userdebug.png&#34;&gt;&lt;img src=&#34;http://enten.github.io/steven/assets/images/fig/mini_emulator_arm64-userdebug-tiny.png&#34; alt=&#34;mini_emulator_arm64-userdebug preview&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;références&#34;&gt;Références&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://source.android.com/source/building.html&#34;&gt;AOSP documentation - Downloading and Building&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://restart-thinking.vitorallo.com/2014/11/ranchu-where-are-you-kernel-and.html&#34;&gt;Ranchu where are you, kernel and emulator aarch64 (arm64)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://android.googlesource.com/platform/external/qemu/+/android-5.0.0_r7/android/qemu-launcher/emulator-qemu.cpp#694&#34;&gt;Code source du fichier emulator-qemu.cpp&lt;/a&gt;, lignes 694-761&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Communications dans les systèmes embarqués par l’emploi d’agents mobiles</title>
      <link>http://enten.github.io/steven/2014/06/01/communications-dans-les-syst%C3%A8mes-embarqu%C3%A9s-par-lemploi-dagents-mobiles/</link>
      <pubDate>Sun, 01 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://enten.github.io/steven/2014/06/01/communications-dans-les-syst%C3%A8mes-embarqu%C3%A9s-par-lemploi-dagents-mobiles/</guid>
      <description>

&lt;h2 id=&#34;contexte&#34;&gt;Contexte&lt;/h2&gt;

&lt;p&gt;Les systèmes embarqués sont le support des périphériques mobiles qui ont envahi notre quotidien : ordinateurs portables, terminaux de poche (« smartphones »), tablettes tactiles, … ont profondément modifiés notre comportement. Les puissances de calculs (de plus en plus grandes) et les moyens de communications (e.g. Wifi, Bluetooth) dont ils disposent leur permettent d&amp;rsquo;interagir entre eux et avec le monde environnant.  Il est possible d’échanger avec l’un de ces systèmes lorsque le périphérique destinataire est joignable par un réseau informatique. Les périodes d’indisponibilités de ces périphériques sont fréquentes au cours de leur cycle d’utilisation (par exemple la perte d’une connexion à un réseau Wifi ou téléphonique mobile lors d’un déplacement).&lt;/p&gt;

&lt;p&gt;Le sujet de ce projet de recherche porte sur l’emploi de la mobilité logicielle dans le but de proposer un modèle de communication nouveau pouvant garantir l’aboutissement des échanges entre systèmes embarqués. La conduite des travaux de ce projet doit permettre : à la société Leuville Objects d’initier une cellule de recherche et développement destinée à améliorer et optimiser ses prestations d’ingénieries informatiques ; de former et d’intégrer progressivement un étudiant – Steven ENTEN, arrivant au terme d’un second cycle universitaire et souhaitant devenir Docteur en informatique spécialisé dans les technologies mobiles – au monde de la recherche et de l’entreprise ; de contribuer aux recherches du groupe « Mobilité », dirigé par Fabrice MOURLIN, du Laboratoire d’Algorithmique,  Complexité et Logique (LACL).&lt;/p&gt;

&lt;p&gt;La société Leuville Objects (LO) a depuis sa création en 1996, eu pour thème d&amp;rsquo;activité les architectures logicielles, leur création, leur gestion mais aussi leur mise en œuvre via l&amp;rsquo;emploi de cadres de développement (« frameworks ») novateurs pour leur époque. Ainsi, dès les premières versions de Java 2 Enterprise Edition (J2EE), des projets ont été montés dans des sociétés clientes par des ingénieurs de LO. De même, lors de l&amp;rsquo;apparition des premiers bus logiciels d&amp;rsquo;entreprise (ESB), LO a fait des choix audacieux autour de produits Open Source tels qu&amp;rsquo;Apache ServiceMix pour offrir à ses clients des solutions nouvelles à base de clusters d&amp;rsquo;ESBs.&lt;/p&gt;

&lt;p&gt;Au cours des années passées, le thème de la virtualisation s&amp;rsquo;est développé dans toutes les sociétés, allant de la virtualisation de serveurs, jusqu&amp;rsquo;au poste client en passant par les réseaux eux même. La société LO souhaite être reconnue auprès de ses partenaires pour son expérience dans ce domaine et plus particulièrement sur le thème de la virtualisation de périphériques mobiles. Ce sujet est lié de manière très étroite à l&amp;rsquo;économie d&amp;rsquo;énergie et l&amp;rsquo;accroissement de la durée d&amp;rsquo;usage des périphériques mobiles tels que les téléphones, tablettes et autres navigateurs [1]. Le sujet de thèse proposé aborde le domaine commun de la virtualisation de périphérique mobile dans un cloud avec la possibilité d&amp;rsquo;exporter tout le contexte d&amp;rsquo;exécution pour en minimiser sa consommation énergétique [4], [7].&lt;/p&gt;

&lt;p&gt;Les résultats obtenus dans cette thèse vont pouvoir directement être intégrés dans les travaux préparatoires effectués au sein de la société LO. Nous pouvons citer : la définition d&amp;rsquo;une architecture logicielle pour la virtualisation de poste mobile, l&amp;rsquo;isolation de machine virtuelle par container, la mise en place d&amp;rsquo;une architecture tolérante aux pannes (« fault tolerance ») pour assurer à l&amp;rsquo;utilisateur la disponibilité de son poste virtualisé. Le suivi régulier de ces travaux est aussi un moyen pour assurer la montée en compétence des ingénieurs sur ces sujets et ainsi développer l&amp;rsquo;activité de recherche et de développement de la société LO.&lt;/p&gt;

&lt;h2 id=&#34;objectif&#34;&gt;Objectif&lt;/h2&gt;

&lt;p&gt;Les périphériques mobiles représentent un des axes stratégiques de développement de la recherche actuelle [6]. La mise au point de ce mécanisme inédit de haute disponibilité des communications doit permettre d’ouvrir la voie à des applications industrielles innovantes. Ce mécanisme consiste à communiquer par l’emploi d’agents mobiles envoyés directement au périphérique destinataire quand celui-ci est joignable. En cas d’indisponibilité du périphérique destinataire, les agents mobiles s’adresseront à un « clone » (une image virtuelle) du périphérique destinataire présent dans un environnement cloud. De cette manière, la communication est assurée entre l’expéditeur et le destinataire. Lorsque le destinataire sera de nouveau joignable, la synchronisation avec son clone sera réalisée par des agents mobiles.&lt;/p&gt;

&lt;p&gt;Le développement d’un prototype logiciel illustrant ce mécanisme – de communication indirecte par l’emploi d’agents mobiles dans un environnement cloud – est l’une des contributions apportées par ce projet de recherche. Avant cela, il sera impératif d’élaborer une spécification formelle qui décrit de manière unique cette haute disponibilité des communications (la garantie que les messages échangés aboutissent malgré une indisponibilité partielle du destinataire). Un modèle temporel devra également être établi afin de vérifier la spécification ainsi que les propriétés temporelles exprimées par cette logique.&lt;/p&gt;

&lt;h2 id=&#34;organisation-des-travaux-de-recherche&#34;&gt;Organisation des travaux de recherche&lt;/h2&gt;

&lt;h3 id=&#34;première-année&#34;&gt;Première année&lt;/h3&gt;

&lt;p&gt;Des travaux seront menés pour valider l’applicabilité de travaux antérieurs portant sur différentes stratégies de communication directe par agents mobiles [2], [3], [8]. Il faudra ensuite les développer pour proposer une stratégie de communication indirecte par cloud.&lt;/p&gt;

&lt;h4 id=&#34;communication-directe&#34;&gt;Communication directe&lt;/h4&gt;

&lt;p&gt;Il s’agira de développer une application distribuée sur deux périphériques embarqués et connectés par un réseau Wifi : le but est de montrer la possibilité d’échanger en direct un agent mobile entre deux tablettes. L’agent échangé – disposant de droits pour s’exécuter sur la plate-forme cible – effectuera une collection d’information avant de retourner sur la plate-forme de départ. Ce cas d’étude se raffine par une configuration initiale de l’agent afin de visiter une suite de périphériques embarqués avec retour. Un point important sera placé sur la description de la demande effectuée par les plates-formes ainsi que la gestion des permissions lors des visites. Un premier rapport de développement sera fourni pour montrer que les principes sont assimilés.&lt;/p&gt;

&lt;h4 id=&#34;communication-indirecte-par-cloud&#34;&gt;Communication indirecte par cloud&lt;/h4&gt;

&lt;p&gt;Le mode de communication précédent présente des limites évidentes. La disponibilité est essentielle, or dans le cadre de périphérique mobile, il faut que ceux-ci soient joignables par le réseau. De plus, l’aspect embarqué des périphériques implique une indisponibilité partielle de parties logicielles en regard des interruptions supportées : appels entrant, alarmes, batterie insuffisante, etc. Il est indispensable d’envisager un autre mode de communication non synchrone dans le cas où le mode précédent ne peut pas être utilisé. Ce mode alternatif consistera pour la partie communicante à envoyer un agent à destination non pas du receveur mais d’une image de ce dernier dans le cloud. Ce clone assurera les services d’accueil de la plate-forme absente. Lorsque celle-ci sera de nouveau disponible, le clone se chargera de sa mise à jour. L’application illustrant ce mode de communication devra être optimisée pour  un système réparti multi-échelle [5].
Un bilan de cette étude sera rédigé en mettant en valeur la pertinence des critères de réalisation. Un point important sera placé sur la description du clone et l’ensemble de son cycle de vie.&lt;/p&gt;

&lt;p&gt;Les stratégies de communication précédemment introduites doivent donner lieu à une validation par prototypage. Chaque prototype sera défini au préalable pour s’assurer des observations faites, puis validé pour s’assurer de l’adéquation avec ce qu’il est censé montrer. Un bilan de cette première année devra être rédigé en anglais afin qu’une publication puisse paraître. Ce bilan devra conclure sur la poursuite du travail réalisé.&lt;/p&gt;

&lt;h3 id=&#34;deuxième-année&#34;&gt;Deuxième année&lt;/h3&gt;

&lt;p&gt;Sur la base du travail réalisé en première année, une application type sera à définir. Elle aura pour principal concept la mobilité d’agents (le plus autonome possible) entre plates-formes nomades. La rédaction des spécifications de cette application devra être menée à son terme pour ensuite débuter sa conception.&lt;/p&gt;

&lt;h4 id=&#34;spécification-formelle&#34;&gt;Spécification formelle&lt;/h4&gt;

&lt;p&gt;Le langage de spécification formelle Pi calcul d’ordre supérieur sera utilisé pour la rédaction des spécifications [10] : ce langage offre un pourvoir d’expression utile pour la description d’agents mobiles. Son étude est un impératif pour pouvoir ensuite décrire de façon formelle le contexte de la communication au sein du réseau.&lt;/p&gt;&lt;/p&gt;

&lt;h4 id=&#34;preuve-de-propriétés&#34;&gt;Preuve de propriétés&lt;/h4&gt;

&lt;p&gt;A partir des spécifications formelles, des propriétés temporelles seront exprimées par l’emploi d’une logique temporelle telle que TCTL [9]. Un modèle temporel sera construit à partir de la spécification en pi calcul. Les propriétés seront ensuite prouvées par model checking, telle que la transparence de communication. Le but est d’assurer que ces propriétés sont préservées lors de la construction du prototype résultat. Un outil tel qu’UPPAAL pourra être utilisé pour la construction d’automates temporisés.&lt;/p&gt;

&lt;p&gt;Un bilan de cette étude formelle sera rédigé en insistant sur le cycle de vie d’un clone de plate-forme (e.g. comme la terminaison d’un clone de plate-forme).&lt;/p&gt;

&lt;h3 id=&#34;troisième-année&#34;&gt;Troisième année&lt;/h3&gt;

&lt;p&gt;Une fois l’application type spécifiée, son prototypage pourra commencer en veillant à respecter les propriétés établies. L’objectif n’est pas d’obtenir une application distribuée utilisable dans le monde de l’industrie mais de valider les résultats de la première année et surtout d’appliquer les points spécifiés au cours de la deuxième année. Les choix techniques de réalisation ainsi que les aspects liés aux propriétés temporelles devront être consignés dans des documents spécifiques.&lt;/p&gt;

&lt;p&gt;Chaque année de recherche donnera lieu à la présentation des résultats dans une conférence internationale reconnue dans le domaine : le travail réalisé y sera présenté. Les publications de la seconde et de la troisième année feront l’objet d’une version étendue afin d’être publiée dans une revue internationale de qualité.&lt;/p&gt;

&lt;h2 id=&#34;références&#34;&gt;Références&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;[1]   H. FLORES, S. N. SRIRAMA, R. BUYYA, “Computational Offloading or Data Binding? Bridging the Cloud Infrastructureto the Proximity of the Mobile User”, in Mobile Cloud Computing, Services, and Engineering, Second IEEE International Conference, 2014&lt;/li&gt;
&lt;li&gt;[2]   C. DUMONT, “Système d’agents mobiles pour les architectures de calculs auto-adaptatifs”, PhD Thesis, 2014&lt;/li&gt;
&lt;li&gt;[3]   C. MAHMOUDI, F. MOURLIN, “Adaptivity of Business Process”, in The Eighth International Conference on Systems, ICONS, 2013&lt;/li&gt;
&lt;li&gt;[4]   S. SIMANTA, K. HA, G. LEWIS, E. MORRIS, M. Satyanarayanan, “A Reference Architecture for Mobile Code Offload in Hostile Environments”, in Software Architecture and European Conference on Software Architecture, 2012&lt;/li&gt;
&lt;li&gt;[5]   S. ROTTENBERG, S. LERICHE,C. LECOCQ, C. TACONET, “Vers une définition d’un système réparti multi-échelle”, in Ubimob, 2012&lt;/li&gt;
&lt;li&gt;[6]   M. SATYANARAYANAN, “Mobile Computing: the Next Decade”, in The First ACM     Workshop on Mobile on Mobile Cloud Computing and Services, 2010&lt;/li&gt;
&lt;li&gt;[7]   M. SATYANARAYANAN, P. BAHL, R. CACERES, N. DAVIES, “The Case for VM-based Cloudlets in Mobile Computing”, in Pervasive Computing, vol. 8, 2009&lt;/li&gt;
&lt;li&gt;[8]   M. BERNICHI, “Surveillance logicielle à base d’une communauté d’agents mobiles”, PhD Thesis, 2009&lt;/li&gt;
&lt;li&gt;[9]   P. BOUYER, “Model-checking Timed Temporal Logics”, in Electronic Notes in Theoretical Computer Science, vol. 231, 2009&lt;/li&gt;
&lt;li&gt;[10]  R. MILNER, “The polyadic p-calculus: a tutorial”, in Technical Report ECS-LFCS-91-180, 1993&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;contact&#34;&gt;Contact&lt;/h2&gt;

&lt;h3 id=&#34;société-leuville-objects&#34;&gt;Société Leuville Objects&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Laurent Nel&lt;/strong&gt;&lt;br /&gt;
3 rue de la Porte de Buc, 78000 Versailles&lt;br /&gt;
+33(0)1 39 50 20 00 – laurent.nel@leuville.com&lt;/p&gt;

&lt;h3 id=&#34;directeur-de-thèse&#34;&gt;Directeur de thèse&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Fabrice Mourlin&lt;/strong&gt;&lt;br /&gt;
LACL, 61 avenue du Général de Gaulle, 94010 Créteil Cedex&lt;br /&gt;
+33(0)6.15.05.15.51 – fabrice.mourlin@u-pec.fr&lt;/p&gt;

&lt;h3 id=&#34;doctorant&#34;&gt;Doctorant&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Steven Enten&lt;/strong&gt;&lt;br /&gt;
21 rue Charles Floquet, 94400 Vitry-sur-Seine&lt;br /&gt;
+33(0)7 70 32 27 55 – steven@enten.fr&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>